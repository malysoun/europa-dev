#!/usr/bin/env python2.7
import sys
import os
import subprocess
import platform
import textwrap


PUBLIC_REPO = "https://github.com/zenoss/europa-dev.git"
PRIVATE_REPO = "https://github.com/zenoss/europa-dev-internal.git"

# Need function to get a single keypress from the user
try:
    # Try Windows
    # noinspection PyUnresolvedReferences
    import msvcrt
    getch = msvcrt.getch
except ImportError:
    # Everything else
    # noinspection PyUnresolvedReferences
    import tty, termios
    def getch():
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(fd)
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch


# Define terminal color-printing functions
def _color_func(colorcode):
    return lambda s: '\033[{0}m{1}\033[0m'.format(colorcode, s)


grey = _color_func(30)
red = _color_func(31)
green = _color_func(32)
yellow = _color_func(33)
blue = _color_func(34)
magenta = _color_func(35)
cyan = _color_func(36)
white = _color_func(37)


# Simple func to get full path relative to PWD
here = lambda *x: os.path.abspath(os.path.join(os.path.curdir, *x))


def say(msg):
    """
    Output a message to the console.
    """
    wrapped = textwrap.wrap(msg)
    print blue("==>"), white(wrapped[0])
    for line in wrapped[1:]:
        print "   ", white(line)


def warn(msg):
    print
    wrapped = textwrap.wrap(msg)
    print red("Warning") + ":", wrapped[0]
    for line in wrapped[1:]:
        print "        ", line


def shell(cmd, **kwargs):
    """
    Run a shell command, printing it first.
    """
    say(' '.join(cmd) if isinstance(cmd, (list, tuple)) else cmd)
    subprocess.call(cmd, shell=True, executable="/bin/bash", **kwargs)

def shell_in_europa(cmd):
    return shell(". $(which virtualenvwrapper.sh) && workon europa && " + cmd)


def error(msg):
    print red("Error:"), msg


def abort(msg):
    error(msg)
    sys.exit(0)


def wait():
    print "Press", blue("ENTER"), "to continue or any other key to abort"
    ch = getch()
    if ord(ch) not in (10, 13):
        abort("Installation aborted by user")


def abort_unless(msg=None):
    print (msg or "Are you sure you want to continue"), blue("[") + "y/N" + blue("]"), "? ",
    ch = getch()
    print
    if ch not in "yY":
        abort("Installation aborted by user")


def git(cmd, **kwargs):
    shell((os.environ.get("GIT") or "git") + " " + cmd, **kwargs)


def which(cmd):
    p = subprocess.Popen(["which", cmd], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    stdout, stderr = p.communicate()
    return stdout


def verify(fname, description=None, use_which=True, die=True, warning=True):
    if use_which:
        result = bool(which(fname))
    else:
        result = os.path.exists(fname)
    if not result and warning:
        msg = "{0} is not present.".format(description or fname)
        (abort if die else warn)(msg)
    return result

def success(*args):
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    return not p.wait() 

def install(pkg, deb_name=None, el_name=None):
    if sys.platform == 'darwin':
        if not verify("brew", die=False):
            say("Can't autoinstall {0} without Homebrew. Get it from http://mxcl.github.io/homebrew/")
        shell("brew install {0}".format(pkg))
    else:
        # Assume linux
        distro, version, ident = platform.linux_distribution()
        if distro.lower() in ("ubuntu", "debian"):
            shell("sudo apt-get install {0}".format(deb_name or pkg))
        elif distro.lower() in ("centos", "rhel", "fedora"):
            shell("sudo yum -y install {0}".format(el_name or pkg))


def install_python(pkg, sudo=False):
    cmd = "pip install"
    if not verify("pip", warning=False):
        cmd = "easy_install"
        if not verify("easy_install", warning=False):
            abort("Neither pip nor setuptools is installed.")
    shell("{0} {1} {2}".format("sudo" if sudo else "", cmd, pkg))


def clone_europa(name, root, repository, branch):
    dotgit = os.path.join(root, '.git')
    if os.path.isdir(dotgit):
        warn("A {1} dev environment already exists in {0}! If you continue, it will be {1}.".format(
            name, root , yellow("ERASED")))
        abort_unless()
        shell("rm -rf {0}".format(root))
    git("clone {0} {1}".format(repository, root))
    git("branch master", cwd=root)
    git("flow init -d".format(repository, root), cwd=root)

    if branch != "master":
        shell("cd {0} && git checkout {1}".format(root, branch))

if __name__ == "__main__":
    EUROPA_ROOT = os.environ.get("EUROPA") or here('europa')
    BRANCH = os.environ.get("EUROPADEV_BRANCH") or "master"
    EUROPAPRIVATE = "EUROPAPRIVATE" in os.environ

    verify("python2.7")
    verify("git")
    verify("vagrant")
    verify("VirtualBox")

    shell("vagrant gem install vagrant-berkshelf")

    if not verify("virtualenvwrapper.sh", description="virtualenvwrapper", die=False):
        install_python("virtualenvwrapper", sudo=True)

    if not success("git", "flow", "version"):
        warn( "git flow is not present.")
        abort_unless("Okay to try to install it?")
        install("git-flow", el_name="gitflow")

    say("Installing a Zenoss development environment into {0}".format(EUROPA_ROOT))
    wait()
    clone_europa( "europa", EUROPA_ROOT, PUBLIC_REPO, BRANCH)
    if EUROPAPRIVATE:
        europa_private_path = os.path.join( EUROPA_ROOT, "private")
        say("Installing a Zenoss private development environment into {0}".format(europa_private_path))
        wait()
        clone_europa( "europa private", europa_private_path, PRIVATE_REPO, BRANCH)

    shell("if [ \"`grep virtualenvwrapper.sh $HOME/.bash_profile` x\" = \" x\" ]; then echo . $(which virtualenvwrapper.sh) >> ~/.bash_profile; fi")
    shell("if [ \"`grep virtualenvwrapper.sh $HOME/.bashrc` x\" = \" x\" ]; then echo . $(which virtualenvwrapper.sh) >> ~/.bashrc; fi")
    shell(". $(which virtualenvwrapper.sh) && mkvirtualenv --clear europa -a " + EUROPA_ROOT)
    
    shell_in_europa("pip install -e {0}/utils/zenoss.europadev".format(EUROPA_ROOT))
    shell_in_europa("git zen clone".format(EUROPA_ROOT))
